*** the â„ start ***

ðŸ–– Hello World,
My name is Shyam; recursive acronymâ€¦

â€¦

*** the start ***

â€¦

*** equality ***

f(x) = x
     ^
     |
     that's an equality
     true unless f(x) already exists; use piecewise notation
     true can't handle any"-thing" but the truth
     ((true) x) makes no cents; or maybe (true x) is true if xâ‰ false

*** what is a function? ***

f(x) = x
  ^    ^
  ||||||
  logic programming in languages such as prolog, and mercury, are better for understanding this
  maybe show an example?
     f(X, Y) :- X + Y
             ^^ ^^^^^
             || |||||
             || i*d*k*â€¦
             is that the right syntax?
     f(3, Y)
  where was i?
  f is the Â¿reference namespace? (i*d*k*â€¦)
  x is: formal parameter, formal argument, free variable (a*k*a* real variable âˆ§ apparent variable)
  3 in f(3) is: actual parameter, actual argument, bound variable
  iprefer
     formal variables & actual constants
     x is formally a variable
     3 in f(3) is actually a constant

f(x) = y
  ^    ^
  ||||||
  show how this relates to coordinate geometry; graphically

*** why Î»? ***

Î» = y
  ^
  |
  Î» is the reflection of y

*** functions treated as numbers ***

Î»x.y
âˆ“3.2
^
|
prefix notation f*t*w*

(+3.2) makes 3.2 positive
(-e.2) makes 3.2 negative
(Î»x.y) makes an inline function

â€¦

*** the end ***

end by saying this is all made redundant by types, so i've wasted your time
(âˆµ this is Â¬ language agnostic; it's probably best to use red colour-coding, or make it language agnostic f*t*w*)
(the only reason i like using haskell âˆ€ e*g* is âˆµ "connect the dots")

id ::    x -> x
id = ( \ x -> x )
 ^ ^     ^^^^^^ ^
 | |     |||||| |
 | |     |||||| throw a lambda in front âˆ§ parenthesise
 | |     copy down the rest
 | |
 | copy down the four dots, and "connect the dots" horizontally 
 copy down the namespace

const ::    x ->     y -> x
const = ( \ x -> ( \ y -> x ) )
    ^
    |
    same as id, but the rule is;
    	lambdas out the front âˆ§ after every arrow/dot, except âˆ€ the last
	parentheses before every lambda, and balance them out in the end

this demonstrates implementation inference
while the inference is bidirections, typing is less typing than typing /lambdas|the implementation/ (less is more than more, more is less than less)
types should start cÌ„ typed lambda calculus âˆ§ end cÌ„ dependent types; the middle should make types intuitive

sorry for the iprefers

*** the â„ end ***

not sure where to put thisâ€¦

SKI jokes (doesn't involve snow, but I could draw an "I know no\"-thing\"" meme)

3K = 1K âˆ´ 3 = 1

Cxy=y âˆ´ konst is const than const (more is less than less, less is more than more)
Why Cxy=y? `K` -> `ê“˜` -> `>` -> `C`
You could also say const is konst than konstâ€¦
C=KI
