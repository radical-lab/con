every"-thing" must flow; types starts c̄ typed lambdas
demonstration by algebraic substitution; probably animate it

*** the ℝ start ***

🖖 Hello World,
My name is Shyam; recursive acronym…

…

*** the start ***

…

*** side effects ***

this is what some programming languages allow you to do

var x = 6
x *= 9 (augmented assignment)
x == 42

var chair = "chair"
var floor = "floor"
	today the word "chair" could mean chair, and the word "floor" could mean floor
	so today i could say "sit on the chair, and place your feet on the floor"
chair = "floor"
floor = "chair"
	but tomorrow the word "chair" could mean floor, and the word "floor" could mean chair
	so tomorrow i could say "sit on the floor, and place your feet on the chair"

this makes it difficult to function in any context
so now lets look at mathematics

3x² +2x +1
explain like terms, and the commutative property
imagine what it would be like if x could arbitrarily change?
it would be impossible to be of any practical use

this is why mathematics, and programming language based on mathematics, avoid side effects
it's side effects, as in the side effects of prescription drugs

*** immutability ***

f(x) = x²
x² doesn't change x; it replaces it c̄ a new value

*** referential transparency ***

f(x) = x²
f(3) = 9
     ^
     |
     that's an equality, which means f(3) ∧ 9 are the same "-thing"

*** equality ***

f(x) = x
     ^
     |
     that's an equation that equates to true ∨ false
     true unless f(x) already exists; use piecewise notation
     true can't handle any"-thing" but the truth
     ((true) x) makes no cents; or maybe (true x) is true if x≠false

*** what is a function? ***

f(x) = x
  ^    ^
  ||||||
  logic programming in languages such as prolog, and mercury, are better for understanding this
  maybe show an example?
     f(X, Y) :- X + Y
             ^^ ^^^^^
             || |||||
             || i*d*k*…
             is that the right syntax?
     f(3, Y)
  where was i?
  f is the ¿reference namespace? (i*d*k*…)
  x is: formal parameter, formal argument, free variable (a*k*a* real variable ∧ apparent variable)
  3 in f(3) is: actual parameter, actual argument, bound variable
  iprefer
     formal variables ∧ actual constants
     x is formally a variable
     3 in f(3) is actually a constant
     or just variables ∧ constants

f(x) = y
  ^    ^
  ||||||
  show how this relates to coordinate geometry; graphically

*** why λ? ***

λ = y
  ^
  |
  λ is the reflection of y

*** functions treated as numbers ***

λx.y
∓3.2
^
|
prefix notation f*t*w*

(+3.2) makes 3.2 positive
(-3.2) makes 3.2 negative
(λx.y) makes an inline function

*** application ***

(F x)…

*** currying ***

…

*** procedural parameters ***

…

*** partial application

(F (G x)) = ((F G) x)…

*** (in)formalities ***

formalities       | informalities
------------------|--------------
(λ x . (λ y . x)) | (λ x y . x)
(F (G x))         | (F G x)
((F G) x)         | (F G x)

∵ formal is often "too formal"; ∀ e*g*:

formalities               | informalities
--------------------------|--------------
(λ x . (λ y . x))         | (λ x y . x)
((λ f . f) ((λ x . x) x)) | ((λ f . f) (λ x . x) x)
(((λ f . f) (λ x . x)) x) | ((λ f . f) (λ x . x) x)

…

*** the end ***

end by saying this is all made redundant by types, so i've wasted your time
(∵ this is ¬ language agnostic; it's probably best to use red colour-coding, or make it language agnostic f*t*w*)
(the only reason i like using haskell ∀ e*g* is ∵ "connect the dots")

id ::    x -> x
id = ( \ x -> x )
 ^ ^     ^^^^^^ ^
 | |     |||||| |
 | |     |||||| throw a lambda in front ∧ parenthesise
 | |     copy down the rest
 | |
 | copy down the four dots, and "connect the dots" horizontally 
 copy down the namespace

const ::    x ->     y -> x
const = ( \ x -> ( \ y -> x ) )
    ^
    |
    same as id, but the rule is;
    	lambdas out the front ∧ after every arrow/dot, except ∀ the last
	parentheses before every lambda, and balance them out in the end

this demonstrates implementation inference
while the inference is bidirections, typing is less typing than typing /lambdas|the implementation/ (less is more than more, more is less than less)
types should start c̄ typed lambda calculus ∧ end c̄ dependent types; the middle should make types intuitive

sorry for the iprefers

*** the ℝ end ***

not sure where to put this…

SKI jokes (doesn't involve snow, but I could draw an "I know no\"-thing\"" meme)

3K = 1K ∴ 3 = 1
the KKK is bad for mathematics #mathsabuse

Cxy=y ∴ konst is const than const (more is less than less, less is more than more)
Why Cxy=y? `K` -> `ꓘ` -> `>` -> `C`
You could also say const is konst than konst…
C=KI
