every"-thing" must flow; types starts cÌ„ typed lambdas
demonstration by algebraic substitution; probably animate it

*** the â„ start ***

ðŸ–– Hello World,
My name is Shyam; recursive acronymâ€¦

â€¦

*** the start ***

â€¦

*** side effects ***

this is what some programming languages allow you to do

var x = 6
x *= 9 (augmented assignment)
x == 42

var chair = "chair"
var floor = "floor"
	today the word "chair" could mean chair, and the word "floor" could mean floor
	so today i could say "sit on the chair, and place your feet on the floor"
chair = "floor"
floor = "chair"
	but tomorrow the word "chair" could mean floor, and the word "floor" could mean chair
	so tomorrow i could say "sit on the floor, and place your feet on the chair"

this makes it difficult to function in any context
so now lets look at mathematics

3xÂ² +2x +1
explain like terms, and the commutative property
imagine what it would be like if x could arbitrarily change?
it would be impossible to be of any practical use

this is why mathematics, and programming language based on mathematics, avoid side effects
it's side effects, as in the side effects of prescription drugs

*** immutability ***

f(x) = xÂ²
xÂ² doesn't change x; it replaces it cÌ„ a new value

*** referential transparency ***

f(x) = xÂ²
f(3) = 9
     ^
     |
     that's an equality, which means f(3) âˆ§ 9 are the same "-thing"

*** equality ***

f(x) = x
     ^
     |
     that's an equation that equates to true âˆ¨ false
     true unless f(x) already exists; use piecewise notation
     true can't handle any"-thing" but the truth
     ((true) x) makes no cents; or maybe (true x) is true if xâ‰ false

*** what is a function? ***

f(x) = x
  ^    ^
  ||||||
  logic programming in languages such as prolog, and mercury, are better for understanding this
  maybe show an example?
     f(X, Y) :- X + Y
             ^^ ^^^^^
             || |||||
             || i*d*k*â€¦
             is that the right syntax?
     f(3, Y)
  where was i?
  f is the Â¿reference namespace? (i*d*k*â€¦)
  x is: formal parameter, formal argument, free variable (a*k*a* real variable âˆ§ apparent variable)
  3 in f(3) is: actual parameter, actual argument, bound variable
  iprefer
     formal variables âˆ§ actual constants
     x is formally a variable
     3 in f(3) is actually a constant
     or just variables âˆ§ constants

f(x) = y
  ^    ^
  ||||||
  show how this relates to coordinate geometry; graphically

*** why Î»? ***

Î» = y
  ^
  |
  Î» is the reflection of y

*** functions treated as numbers ***

Î»x.y
âˆ“3.2
^
|
prefix notation f*t*w*

(+3.2) makes 3.2 positive
(-3.2) makes 3.2 negative
(Î»x.y) makes an inline function

*** application ***

(F x)â€¦

*** currying ***

â€¦

*** procedural parameters ***

â€¦

*** partial application

(F (G x)) = ((F G) x)â€¦

*** (in)formalities ***

formalities       | informalities
------------------|--------------
(Î» x . (Î» y . x)) | (Î» x y . x)
(F (G x))         | (F G x)
((F G) x)         | (F G x)

âˆµ formal is often "too formal"; âˆ€ e*g*:

formalities               | informalities
--------------------------|--------------
(Î» x . (Î» y . x))         | (Î» x y . x)
((Î» f . f) ((Î» x . x) x)) | ((Î» f . f) (Î» x . x) x)
(((Î» f . f) (Î» x . x)) x) | ((Î» f . f) (Î» x . x) x)

â€¦

*** the end ***

end by saying this is all made redundant by types, so i've wasted your time
(âˆµ this is Â¬ language agnostic; it's probably best to use red colour-coding, or make it language agnostic f*t*w*)
(the only reason i like using haskell âˆ€ e*g* is âˆµ "connect the dots")

id ::    x -> x
id = ( \ x -> x )
 ^ ^     ^^^^^^ ^
 | |     |||||| |
 | |     |||||| throw a lambda in front âˆ§ parenthesise
 | |     copy down the rest
 | |
 | copy down the four dots, and "connect the dots" horizontally 
 copy down the namespace

const ::    x ->     y -> x
const = ( \ x -> ( \ y -> x ) )
    ^
    |
    same as id, but the rule is;
    	lambdas out the front âˆ§ after every arrow/dot, except âˆ€ the last
	parentheses before every lambda, and balance them out in the end

this demonstrates implementation inference
while the inference is bidirections, typing is less typing than typing /lambdas|the implementation/ (less is more than more, more is less than less)
types should start cÌ„ typed lambda calculus âˆ§ end cÌ„ dependent types; the middle should make types intuitive

sorry for the iprefers

*** the â„ end ***

not sure where to put thisâ€¦

SKI jokes (doesn't involve snow, but I could draw an "I know no\"-thing\"" meme)

3K = 1K âˆ´ 3 = 1
the KKK is bad for mathematics #mathsabuse

Cxy=y âˆ´ konst is const than const (more is less than less, less is more than more)
Why Cxy=y? `K` -> `ê“˜` -> `>` -> `C`
You could also say const is konst than konstâ€¦
C=KI
